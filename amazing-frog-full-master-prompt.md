# Amazing-Frog Water Station Angular Dashboard — Full Master Prompt

You are an expert Angular architect and TypeScript developer. Generate the **complete Angular application** described below.  
Your output must include all required code files, full implementations, and best practices.

This prompt defines the complete specification for the **Amazing-Frog Water Station Dashboard**, an Angular web application that consumes USGS Water Data OGC APIs and is deployed on GitHub Pages.

---

# 1. PROJECT OVERVIEW

Build a production-ready Angular application called **Amazing-Frog Water Station Dashboard**.

The app will:

- Provide a cascading selection interface:
  1. **State** dropdown (populated on page load)
  2. **County** dropdown (populated after state selection)
  3. **Monitoring Location** dropdown (populated after county selection)
- Retrieve and display:
  - Station metadata card
  - **Gage Height** chart (last 90 days, parameter code 00065)
  - **Streamflow/Discharge** chart (last 90 days, parameter code 00060)
- Handle edge cases:
  - Loading states
  - Empty data (show "No data available" message)
  - API errors with user-friendly messages

---

# 1.5 PREREQUISITE: CLEAN PROJECT STRUCTURE

**Before generating the application, ensure your project has the correct structure:**

### Step 1: Delete Build Artifacts
Delete the following folders/files if they exist:
- `docs/` folder
- `dist/` folder
- Any `.js` files in `src/`

### Step 2: Install Dependencies
After updating `package.json`, run:
```bash
npm install
```

Then add Angular Material using the Angular CLI:
```bash
ng add @angular/material
```

When prompted:
- Choose a theme: **Indigo/Pink** (or any prebuilt theme)
- Set up typography: **Yes**
- Include animations: **Yes**

This will install:
- Angular Material (compatible version for Angular 20)
- Angular CDK (Component Dev Kit)
- Chart.js 4.4
- chartjs-adapter-date-fns for time series
- All required Angular packages

### Files to Keep (Source Files):
- `src/index.html` - Main HTML entry point
- `src/main.ts` - Application bootstrap
- `src/styles.scss` - Global styles
- `src/app/app.ts` (or `app.component.ts`) - Root component
- `src/app/app.config.ts` - Application configuration
- `src/app/app.routes.ts` - Routing configuration
- `angular.json` - Angular CLI configuration
- `package.json` - Dependencies
- `tsconfig.json` - TypeScript configuration

### Files/Folders to Delete (Build Artifacts):
- `docs/` folder - This is generated by the build process, delete it before development
- Any `.js` files in `src/` - These are compiled outputs
- `dist/` folder (if present) - Build output folder

### Correct Project Root Structure:
```
amazing-frog/
├── src/
│   ├── app/
│   │   ├── app.ts (or app.component.ts)
│   │   ├── app.config.ts
│   │   ├── app.routes.ts
│   │   ├── app.html
│   │   └── app.scss
│   ├── index.html
│   ├── main.ts
│   └── styles.scss
├── public/
├── angular.json
├── package.json
├── tsconfig.json
└── README.md
```

**Important:** The `docs/` folder should ONLY exist after running `ng build` for deployment. During development, it should not exist.

---

# 2. DEPLOYMENT REQUIREMENTS

This Angular app **must work on GitHub Pages**:

### 2.1 Production Build
```bash
ng build --configuration production --output-path docs --base-href /amazing-frog/
```
*(Replace `/amazing-frog/` with your actual repository name)*

### 2.2 Routing Configuration
Use `HashLocationStrategy` because GitHub Pages cannot handle Angular routing without a server.

```typescript
// app.config.ts
import { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';
import { provideRouter, withHashLocation } from '@angular/router';
import { provideHttpClient, withFetch } from '@angular/common/http';
import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideRouter(routes, withHashLocation()),
    provideHttpClient(withFetch())
  ]
};
```

### 2.3 GitHub Pages Setup
- Build output goes to `docs/` folder
- Create `docs/404.html` that redirects to `index.html`:
```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Amazing Frog</title>
  <script>
    sessionStorage.redirect = location.href;
  </script>
  <meta http-equiv="refresh" content="0;URL='/amazing-frog/'">
</head>
<body></body>
</html>
```
- Enable GitHub Pages in repository settings → Pages → Source: `docs/` folder

### 2.4 Important: Base HREF Configuration
- For local development: `<base href="/">` in `src/index.html`
- For GitHub Pages: Set via build command `--base-href /repository-name/`

---

# 3. TECHNOLOGY STACK

### Core Framework
- **Angular 20.3** (as specified in package.json)
- **TypeScript 5.9** with strict mode
- **Angular CLI 20.3** with application builder
- **RxJS 7.8** with reactive patterns

### UI Framework
- **Angular Material** (latest version compatible with Angular 20)
- Angular CDK for component utilities
- **Note:** Material version may be 19.x as it lags behind core Angular releases
  - Form controls (mat-select)
  - Cards (mat-card)
  - Progress indicators (mat-spinner, mat-progress-bar)
  - Grid layout (responsive)
  - Date range picker (mat-date-range-input) - optional for future enhancement

### Charts
- **Chart.js 4.4+** with direct Canvas rendering
- **chartjs-adapter-date-fns** for time axis support
- Two responsive line charts with:
  - Proper time axis formatting
  - Tooltips showing date and value
  - Responsive design
  - Legend
  - Grid lines

**Important:** Use Chart.js directly with Angular's `ViewChild` and Canvas element, not ng2-charts (incompatible with Angular 20).

### Code Quality Standards
- Strongly typed interfaces for all data
- Reactive patterns (no nested subscriptions)
- RxJS operators: `switchMap`, `tap`, `catchError`, `shareReplay`, `map`
- `async` pipe in templates (avoid manual subscriptions)
- Error handling service
- Loading state management

---

# 4. USGS OGC API INTEGRATION

**API Documentation:** https://api.waterdata.usgs.gov/ogcapi/v0/openapi#/

**Base URL:**
```
https://api.waterdata.usgs.gov/ogcapi/v0
```

All API responses follow GeoJSON format. The actual data is nested in `features[]` array.

---

## 4.1 Get States

**Endpoint:**
```
GET /collections/states/items?f=json&country_code=US&limit=10000
```

**Response Structure:**
```json
{
  "features": [
    {
      "properties": {
        "state_name": "Indiana",
        "state_fips_code": "18"
      }
    }
  ]
}
```

**Service Method:**
```typescript
getStates(): Observable<State[]> {
  return this.http.get<GeoJSONResponse>(`${baseUrl}/collections/states/items`, {
    params: { f: 'json', country_code: 'US', limit: '10000' }
  }).pipe(
    map(response => response.features.map(f => ({
      state_code: f.properties.state_fips_code,
      state_name: f.properties.state_name
    }))),
    shareReplay(1), // Cache states
    catchError(this.handleError)
  );
}
```

---

## 4.2 Get Counties

**Endpoint:**
```
GET /collections/counties/items?f=json&country_code=US&state_fips_code={stateCode}&limit=10000
```

**Response Structure:**
```json
{
  "features": [
    {
      "properties": {
        "county_name": "Montgomery County",
        "county_fips_code": "107",
        "state_fips_code": "18"
      }
    }
  ]
}
```

**Service Method:**
```typescript
getCounties(stateFipsCode: string): Observable<County[]>
```

---

## 4.3 Get Monitoring Locations

**Endpoint:**
```
GET /collections/monitoring-locations/items?f=json&country_code=US&state_fips_code={stateCode}&county_fips_code={countyCode}&site_type=Stream&limit=1000
```

**Response Structure:**
```json
{
  "features": [
    {
      "id": "USGS-03339500",
      "properties": {
        "monitoring_location_name": "SUGAR CREEK AT CRAWFORDSVILLE, IN",
        "monitoring_location_type": "Stream",
        "county_name": "Montgomery County"
      },
      "geometry": {
        "coordinates": [-86.874, 40.042]
      }
    }
  ]
}
```

**Service Method:**
```typescript
getMonitoringLocations(stateFipsCode: string, countyFipsCode: string): Observable<MonitoringLocation[]>
```

---

## 4.4 Get Time Series Data (Gage Height & Discharge)

**Endpoint Pattern:**
```
GET /collections/daily/items?monitoring_location_id=USGS-{id}&parameter_code={code}&statistic_id=00003&datetime={start}/{end}&limit=10000&f=json
```

**Parameters:**
- `monitoring_location_id`: e.g., `USGS-03339500`
- `parameter_code`: 
  - `00065` = Gage Height (ft)
  - `00060` = Streamflow (ft³/s)
- `statistic_id`: `00003` = daily mean
- `datetime`: ISO date range, e.g., `2025-08-16/2025-11-16` (90 days)

**Response Structure:**
```json
{
  "numberReturned": 92,
  "features": [
    {
      "properties": {
        "time": "2025-11-02T00:00:00Z",
        "value": 7.02,
        "unit_of_measure": "ft"
      }
    }
  ]
}
```

**Service Methods:**
```typescript
getGageHeight(locationId: string, startDate: string, endDate: string): Observable<TimeSeriesData>

getStreamflow(locationId: string, startDate: string, endDate: string): Observable<TimeSeriesData>
```

**Date Calculation:**
```typescript
// Get last 90 days
const endDate = new Date();
const startDate = new Date();
startDate.setDate(endDate.getDate() - 90);

const dateRange = `${startDate.toISOString().split('T')[0]}/${endDate.toISOString().split('T')[0]}`;
```

---

# 5. DATA MODELS

Create strongly-typed interfaces:

```typescript
// GeoJSON wrapper
export interface GeoJSONResponse {
  features: GeoJSONFeature[];
  numberReturned?: number;
}

export interface GeoJSONFeature {
  id?: string;
  properties: any;
  geometry?: {
    coordinates: [number, number]; // [longitude, latitude]
  };
}

// Domain models
export interface State {
  state_code: string;
  state_name: string;
}

export interface County {
  county_code: string;
  county_name: string;
  state_code: string;
}

export interface MonitoringLocation {
  id: string;
  name: string;
  type: string;
  county_name: string;
  latitude: number;
  longitude: number;
}

export interface TimeSeriesPoint {
  time: string; // ISO 8601 date
  value: number;
}

export interface TimeSeriesData {
  locationId: string;
  parameterCode: string;
  parameterName: string;
  unit: string;
  points: TimeSeriesPoint[];
  hasData: boolean; // true if points.length > 0
}
```

---

# 6. APPLICATION STRUCTURE

Use Angular 20 standalone components (modern approach):

```
src/
  app/
    app.ts                    # Root component (named App, not AppComponent)
    app.html                  # Root component template
    app.scss                  # Root component styles
    app.config.ts             # Application configuration
    app.routes.ts             # Routing configuration
    
    services/
      usgs-api.service.ts
      error-handler.service.ts
    
    models/
      api.models.ts
      domain.models.ts
    
    components/
      dashboard/
        dashboard.component.ts
        dashboard.component.html
        dashboard.component.scss
      
      site-card/
        site-card.component.ts
        site-card.component.html
        site-card.component.scss
      
      chart/
        chart.component.ts
        chart.component.html
        chart.component.scss
```

**Note:** The root component is named `App` (not `AppComponent`) and uses separate template/style files (`app.html`, `app.scss`).

**Chart Component:** Uses Chart.js directly via Canvas element and `@ViewChild`, not a wrapper library.

---

# 7. DASHBOARD COMPONENT REQUIREMENTS

## 7.1 Layout Structure

Use CSS Grid for responsive layout:

```
Desktop (>= 960px):
┌─────────────────┬───────────────────────┐
│                 │                       │
│  Control Panel  │   Station Info Card   │
│                 │                       │
│  - State        ├───────────────────────┤
│  - County       │                       │
│  - Location     │  Gage Height Chart    │
│                 │                       │
│                 ├───────────────────────┤
│                 │                       │
│                 │  Streamflow Chart     │
│                 │                       │
└─────────────────┴───────────────────────┘

Mobile (< 960px): Stack vertically
```

## 7.2 Control Panel Features

**State Dropdown:**
- Load states on component init
- Show loading spinner while fetching
- Sort alphabetically
- Auto-select first state (optional)

**County Dropdown:**
- Disabled until state selected
- Clear selection when state changes
- Show loading indicator

**Monitoring Location Dropdown:**
- Disabled until county selected
- Clear selection when county changes
- Display format: `{name} (ID: {id})`

**UX Requirements:**
- Show loading indicators for each dropdown
- Disable dependent dropdowns until parent is selected
- Clear child selections when parent changes
- Show error messages if API calls fail

## 7.3 Station Info Card

Display when monitoring location is selected:

- **Station Name**
- **USGS ID** (e.g., USGS-03339500)
- **Type** (e.g., Stream)
- **County**
- **Coordinates** (Latitude, Longitude)
- **Link to USGS site** (optional)

## 7.4 Charts

**Implementation Approach:**
Create a reusable `ChartComponent` that accepts data via `@Input()` and renders using Chart.js directly.

**CRITICAL: Chart Data Sorting**
The USGS API returns data in random order. **YOU MUST SORT THE TIME SERIES DATA CHRONOLOGICALLY** before rendering charts:

```typescript
// In usgs-api.service.ts - getTimeSeries method
map(response => {
  // Extract and SORT points by date
  const points = response.features
    .map(f => ({
      time: f.properties.time,
      value: f.properties.value
    }))
    .sort((a, b) => new Date(a.time).getTime() - new Date(b.time).getTime());
  
  return {
    locationId,
    parameterCode,
    parameterName,
    unit,
    points,
    hasData: (response.numberReturned || 0) > 0 && points.length > 0
  };
})
```

**Example Chart Component:**
```typescript
import { Component, ViewChild, ElementRef, Input, OnChanges, AfterViewInit, OnDestroy, SimpleChanges } from '@angular/core';
import { Chart, ChartConfiguration } from 'chart.js/auto';
import 'chartjs-adapter-date-fns';

@Component({
  selector: 'app-chart',
  template: '<div class="chart-wrapper"><canvas #chartCanvas></canvas></div>',
  styles: [`
    .chart-wrapper {
      height: 400px;
      width: 100%;
      position: relative;
      padding: 16px;
    }
    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }
  `],
  standalone: true
})
export class ChartComponent implements AfterViewInit, OnChanges, OnDestroy {
  @ViewChild('chartCanvas') canvasRef!: ElementRef<HTMLCanvasElement>;
  @Input() data: TimeSeriesPoint[] = [];
  @Input() title = '';
  @Input() yAxisLabel = '';
  @Input() lineColor = '#3f51b5';
  
  private chart?: Chart;
  
  ngAfterViewInit() {
    this.createChart();
  }
  
  ngOnChanges(changes: SimpleChanges) {
    if (this.chart && changes['data']) {
      this.updateChart();
    }
  }
  
  ngOnDestroy() {
    if (this.chart) {
      this.chart.destroy();
    }
  }
  
  private createChart() {
    if (!this.canvasRef) return;
    
    const config: ChartConfiguration<'line'> = {
      type: 'line',
      data: {
        datasets: [{
          label: this.yAxisLabel,
          data: this.data.map(p => ({ x: new Date(p.time).getTime(), y: p.value })),
          borderColor: this.lineColor,
          backgroundColor: this.lineColor + '20',
          fill: false,
          tension: 0.4,
          pointRadius: 3,
          pointHoverRadius: 6,
          borderWidth: 2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: {
            display: true,
            text: this.title,
            font: { size: 16, weight: 'bold' }
          },
          legend: { display: false },
          tooltip: { mode: 'index', intersect: false }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day',
              displayFormats: { day: 'MMM d' }
            },
            title: { display: true, text: 'Date' }
          },
          y: {
            beginAtZero: false,
            title: { display: true, text: this.yAxisLabel }
          }
        }
      };
    
    this.chart = new Chart(this.canvasRef.nativeElement, config);
  }
  
  private updateChart() {
    if (!this.chart) return;
    this.chart.data.datasets[0].data = this.data.map(p => ({ 
      x: new Date(p.time).getTime(), 
      y: p.value 
    }));
    this.chart.update();
  }
}
```

**Chart Layout:**
- **Streamflow Chart appears FIRST (top)**
- **Gage Height Chart appears SECOND (bottom)**

```html
<!-- Charts Section - CORRECT ORDER -->
<div class="charts-section">
  <!-- STREAMFLOW FIRST -->
  <mat-card class="chart-card">
    <app-chart 
      *ngIf="streamflowData$ | async as data; else loading"
      [data]="data.points"
      [title]="'Daily Streamflow (Last 90 Days)'"
      [yAxisLabel]="'Discharge (' + data.unit + ')'"
      [lineColor]="'#4CAF50'">
    </app-chart>
  </mat-card>

  <!-- GAGE HEIGHT SECOND -->
  <mat-card class="chart-card">
    <app-chart 
      *ngIf="gageHeightData$ | async as data; else loading"
      [data]="data.points"
      [title]="'Daily Gage Height (Last 90 Days)'"
      [yAxisLabel]="'Height (' + data.unit + ')'"
      [lineColor]="'#2196F3'">
    </app-chart>
  </mat-card>
</div>
```

---

# 9. REACTIVE STATE MANAGEMENT

## 9.1 Critical: Observable Subscription Strategy

**ISSUE:** Chart observables based on `valueChanges` don't emit until a value changes, causing first selection to show infinite loading spinner.

**SOLUTION:** Use `shareReplay({ bufferSize: 1, refCount: false })` AND eagerly subscribe in `ngOnInit()`.

```typescript
export class DashboardComponent implements OnInit {
  // Form controls
  stateControl = new FormControl<string | null>(null);
  countyControl = new FormControl<string | null>({ value: null, disabled: true });
  locationControl = new FormControl<string | null>({ value: null, disabled: true });
  
  // Data streams
  states$!: Observable<State[]>;
  counties$!: Observable<County[]>;
  locations$!: Observable<MonitoringLocation[]>;
  gageHeightData$!: Observable<TimeSeriesData | null>;
  streamflowData$!: Observable<TimeSeriesData | null>;
  
  ngOnInit() {
    this.setupStreams();
    
    // Trigger API calls
    this.states$.subscribe();
    this.counties$.subscribe();
    this.locations$.subscribe();
    
    // CRITICAL: Eagerly subscribe to chart observables
    // This ensures they're "hot" and ready before template's async pipe subscribes
    this.gageHeightData$.subscribe();
    this.streamflowData$.subscribe();
  }
  
  private setupStreams() {
    // States (cached)
    this.states$ = this.usgsService.getStates().pipe(
      shareReplay(1)
    );
    
    // Counties (reload on state change)
    this.counties$ = this.stateControl.valueChanges.pipe(
      filter(state => !!state),
      tap(() => {
        this.countyControl.reset();
        this.countyControl.disable();
        this.locationControl.reset();
        this.locationControl.disable();
      }),
      switchMap(state => this.usgsService.getCounties(state!).pipe(
        tap(() => this.countyControl.enable())
      )),
      shareReplay(1)
    );
    
    // Locations (reload on county change)
    this.locations$ = this.countyControl.valueChanges.pipe(
      filter(county => !!county),
      tap(() => {
        this.locationControl.reset();
        this.locationControl.disable();
      }),
      switchMap(county => {
        const state = this.stateControl.value!;
        return this.usgsService.getMonitoringLocations(state, county!).pipe(
          tap(() => this.locationControl.enable())
        );
      }),
      shareReplay(1)
    );
    
    // Date range calculator
    const getDateRange = () => {
      const endDate = new Date();
      const startDate = new Date(endDate);
      startDate.setDate(endDate.getDate() - 90);
      return {
        start: startDate.toISOString().split('T')[0],
        end: endDate.toISOString().split('T')[0]
      };
    };
    
    // Gage height - NO startWith(), refCount: false, eager subscription
    this.gageHeightData$ = this.locationControl.valueChanges.pipe(
      switchMap((loc): Observable<TimeSeriesData | null> => {
        if (!loc) return of(null);
        const { start, end } = getDateRange();
        return this.usgsService.getGageHeight(loc, start, end);
      }),
      shareReplay({ bufferSize: 1, refCount: false }) // Keep hot
    );
    
    // Streamflow - NO startWith(), refCount: false, eager subscription
    this.streamflowData$ = this.locationControl.valueChanges.pipe(
      switchMap((loc): Observable<TimeSeriesData | null> => {
        if (!loc) return of(null);
        const { start, end } = getDateRange();
        return this.usgsService.getStreamflow(loc, start, end);
      }),
      shareReplay({ bufferSize: 1, refCount: false }) // Keep hot
    );
  }
}
```

**Why this works:**
1. `valueChanges` doesn't emit until a value changes
2. `refCount: false` keeps observable alive even with no subscribers
3. Eager subscription in `ngOnInit()` triggers the observable chain
4. Template's `async` pipe gets cached value immediately
5. Charts render on first selection ✅

**Template Pattern:**
```html
<mat-card class="chart-card">
  @if (streamflowData$ | async; as data) {
    @if (data.hasData) {
      <app-chart [data]="data.points" ...></app-chart>
    } @else {
      <mat-card-content>
        <p class="no-data">No streamflow data available</p>
      </mat-card-content>
    }
  } @else if (locationControl.value) {
    <mat-card-content class="loading-content">
      <mat-spinner diameter="40"></mat-spinner>
      <p>Loading streamflow data...</p>
    </mat-card-content>
  } @else {
    <mat-card-content>
      <p class="no-data">Select a monitoring location</p>
    </mat-card-content>
  }
</mat-card>
```

---

# 10. USGS API SERVICE IMPLEMENTATION

## 10.1 Critical Fixes

### Fix 1: Filter USGS Locations Only
Add `agency_code=USGS` parameter to exclude state monitoring sites:

```typescript
getMonitoringLocations(stateFipsCode: string, countyFipsCode: string): Observable<MonitoringLocation[]> {
  return this.http.get<GeoJSONResponse>(`${this.baseUrl}/collections/monitoring-locations/items`, {
    params: {
      f: 'json',
      country_code: 'US',
      state_code: stateFipsCode,
      county_code: countyFipsCode,
      agency_code: 'USGS', // CRITICAL: Filter USGS sites only
      site_type: 'Stream',
      limit: '1000'
    }
  }).pipe(
    map(response => response.features.map(f => ({
      id: f.id || '', // Keep full ID as-is (e.g., USGS-03339500)
      name: f.properties.monitoring_location_name,
      type: f.properties.site_type || 'Stream',
      county_name: f.properties.county_name,
      latitude: f.geometry?.coordinates[1] || 0,
      longitude: f.geometry?.coordinates[0] || 0
    }))),
    catchError(this.errorHandler.handleError)
  );
}
```

### Fix 2: Sort Time Series Data Chronologically

```typescript
private getTimeSeries(
  locationId: string,
  parameterCode: string,
  startDate: string,
  endDate: string,
  parameterName: string,
  unit: string
): Observable<TimeSeriesData> {
  const datetime = `${startDate}/${endDate}`;
  
  return this.http.get<GeoJSONResponse>(`${this.baseUrl}/collections/daily/items`, {
    params: {
      monitoring_location_id: locationId, // Use ID as-is (already has USGS- prefix)
      parameter_code: parameterCode,
      statistic_id: '00003',
      datetime: datetime,
      limit: '10000',
      f: 'json'
    }
  }).pipe(
    map(response => {
      // CRITICAL: Sort points chronologically
      const points = response.features
        .map(f => ({
          time: f.properties.time,
          value: f.properties.value
        }))
        .sort((a, b) => new Date(a.time).getTime() - new Date(b.time).getTime());
      
      return {
        locationId,
        parameterCode,
        parameterName,
        unit,
        points,
        hasData: (response.numberReturned || 0) > 0 && points.length > 0
      };
    }),
    catchError(this.errorHandler.handleError)
  );
}
```

### Fix 3: Don't Manipulate Location IDs

**WRONG:**
```typescript
const stationId = fullId.replace('USGS-', ''); // DON'T DO THIS
monitoring_location_id: `USGS-${locationId}` // DON'T DO THIS
```

**CORRECT:**
```typescript
// Store IDs exactly as API returns them
id: f.id || '' // Keep "USGS-03339500"

// Use IDs exactly as stored
monitoring_location_id: locationId // Already has "USGS-" prefix
```

---

# 11. ERROR HANDLING

Create a dedicated error handler service:

```typescript
import { Injectable } from '@angular/core';
import { HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class ErrorHandlerService {
  handleError(error: HttpErrorResponse): Observable<never> {
    let userMessage = 'An error occurred. Please try again.';
    
    if (error.status === 0) {
      userMessage = 'Network error. Please check your connection.';
    } else if (error.status >= 500) {
      userMessage = 'Server error. Please try again later.';
    } else if (error.status === 404) {
      userMessage = 'Data not found.';
    }
    
    // Show snackbar or notification
    console.error('API Error:', error);
    return throwError(() => new Error(userMessage));
  }
}
```

---

# 12. STYLING REQUIREMENTS

## 12.1 Material Theme

Use a pre-built Angular Material theme or create custom:

```scss
@use '@angular/material' as mat;

$primary: mat.define-palette(mat.$indigo-palette);
$accent: mat.define-palette(mat.$pink-palette);

$theme: mat.define-light-theme((
  color: (
    primary: $primary,
    accent: $accent,
  )
));

@include mat.all-component-themes($theme);
```

## 12.2 Responsive Design

```scss
.dashboard-grid {
  display: grid;
  grid-template-columns: 300px 1fr;
  gap: 16px;
  padding: 16px;
  
  @media (max-width: 960px) {
    grid-template-columns: 1fr;
  }
}

.chart-card {
  min-height: 450px; // Ensure card has minimum height
  
  mat-card-content {
    height: 100%;
    min-height: 400px;
  }
}

.chart-wrapper {
  height: 400px; // Fixed height for chart container
  width: 100%;
  position: relative;
  padding: 16px;
}

canvas {
  display: block;
  width: 100% !important;
  height: 100% !important;
}
```

---

# 13. COMMON ISSUES AND SOLUTIONS

## Issue 1: Infinite Loading Spinner on First Selection
**Symptom:** First monitoring location shows spinner forever, second location works.

**Root Cause:** `valueChanges` doesn't emit until value changes. With `refCount: true`, observable doesn't execute until template's `async` pipe subscribes, but by then it's too late.

**Solution:**
1. Use `shareReplay({ bufferSize: 1, refCount: false })`
2. Eagerly subscribe in `ngOnInit()`: `this.gageHeightData$.subscribe();`

## Issue 2: Chart Shows Scribbled Lines (Random Order)
**Symptom:** Chart line connects points randomly (Nov 8 → Aug 31 → Oct 6).

**Root Cause:** USGS API returns data in random order.

**Solution:** Sort points chronologically in service before returning:
```typescript
.sort((a, b) => new Date(a.time).getTime() - new Date(b.time).getTime())
```

## Issue 3: Charts Too Narrow
**Symptom:** Charts render less than 1 inch tall.

**Root Cause:** Chart.js defaults to maintaining aspect ratio.

**Solution:**
1. Set fixed height on wrapper: `height: 400px`
2. Set `maintainAspectRatio: false` in Chart.js options
3. Force canvas size: `width: 100% !important; height: 100% !important;`

## Issue 4: Non-USGS Stations in Dropdown
**Symptom:** Locations like `IN033-400230086562101` appear but have no data.

**Root Cause:** State monitoring sites don't have time series data.

**Solution:** Add `agency_code: 'USGS'` parameter to monitoring locations API call.

## Issue 5: Wrong Chart Order
**Symptom:** Gage Height appears above Streamflow.

**Solution:** Always render Streamflow first, Gage Height second in template.

---

# 14. ACCESSIBILITY

- Use semantic HTML
- Include ARIA labels for form controls
- Ensure keyboard navigation works
- Provide alt text for charts (via aria-label)
- Maintain color contrast ratios (WCAG AA)

---

# 15. TESTING REQUIREMENTS

## 15.1 Unit Tests
- Service methods (mock HTTP responses)
- Component logic   - Build commands
- Reactive stream transformations- Deployment steps
6. **Updated package.json** with all dependencies
## 15.2 E2E Tests (Optional)ow** for automated deployment (optional)
- Complete user flow: State → County → Location → Charts

Your generated code must include:

1. **Complete Angular 20 standalone application**
2. **All TypeScript files** with full implementations
3. **HTML templates** with proper structure
4. **SCSS styles** with responsive designs/` folder
5. **README.md** with:ml` redirect
   - Setup instructionstrategy in app.config.ts
   - Build commands- [ ] Test locally: `npx http-server docs`
   - Deployment steps ] Push to GitHub
6. **Updated package.json** with all dependencies- [ ] Enable GitHub Pages
7. **GitHub Actions workflow** for automated deployment (optional)

---

# 16. DEPLOYMENT CHECKLIST

- [ ] Build with production configurationtom time periods
- [ ] Set correct `--base-href`SV
- [ ] Output to `docs/` folder
- [ ] Create `docs/404.html` redirect- Real-time data updates
- [ ] Use HashLocationStrategy in app.config.tsobile app with Capacitor
- [ ] Test locally: `npx http-server docs`- Dark mode toggle
- [ ] Push to GitHubalStorage)
- [ ] Enable GitHub Pages
- [ ] Verify deployment



















This prompt serves as the canonical reference for building and maintaining the Amazing-Frog Water Station Dashboard using Angular 20.3, TypeScript 5.9, and RxJS 7.8 as specified in the project's package.json.**END OF SPECIFICATION**---- Favorite stations (localStorage)- Dark mode toggle- Mobile app with Capacitor- Real-time data updates- Compare multiple stations- Export data to CSV- Date range picker for custom time periods# 17. FUTURE ENHANCEMENTS (Optional)---**END OF SPECIFICATION**

This prompt serves as the canonical reference for building and maintaining the Amazing-Frog Water Station Dashboard using Angular 20.3, TypeScript 5.9, and RxJS 7.8 as specified in the project's package.json.
